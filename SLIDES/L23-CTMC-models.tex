\documentclass[aspectratio=169]{beamer}\usepackage[]{graphicx}\usepackage[]{xcolor}
% maxwidth is the original width if it is less than linewidth
% otherwise use linewidth (to make sure the graphics do not exceed the margin)
\makeatletter
\def\maxwidth{ %
  \ifdim\Gin@nat@width>\linewidth
    \linewidth
  \else
    \Gin@nat@width
  \fi
}
\makeatother

\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}
\newcommand{\hlnum}[1]{\textcolor[rgb]{0.686,0.059,0.569}{#1}}%
\newcommand{\hlsng}[1]{\textcolor[rgb]{0.192,0.494,0.8}{#1}}%
\newcommand{\hlcom}[1]{\textcolor[rgb]{0.678,0.584,0.686}{\textit{#1}}}%
\newcommand{\hlopt}[1]{\textcolor[rgb]{0,0,0}{#1}}%
\newcommand{\hldef}[1]{\textcolor[rgb]{0.345,0.345,0.345}{#1}}%
\newcommand{\hlkwa}[1]{\textcolor[rgb]{0.161,0.373,0.58}{\textbf{#1}}}%
\newcommand{\hlkwb}[1]{\textcolor[rgb]{0.69,0.353,0.396}{#1}}%
\newcommand{\hlkwc}[1]{\textcolor[rgb]{0.333,0.667,0.333}{#1}}%
\newcommand{\hlkwd}[1]{\textcolor[rgb]{0.737,0.353,0.396}{\textbf{#1}}}%
\let\hlipl\hlkwb

\usepackage{framed}
\makeatletter
\newenvironment{kframe}{%
 \def\at@end@of@kframe{}%
 \ifinner\ifhmode%
  \def\at@end@of@kframe{\end{minipage}}%
  \begin{minipage}{\columnwidth}%
 \fi\fi%
 \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
 \colorbox{shadecolor}{##1}\hskip-\fboxsep
     % There is no \\@totalrightmargin, so:
     \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed%
 \at@end@of@kframe}
\makeatother

\definecolor{shadecolor}{rgb}{.97, .97, .97}
\definecolor{messagecolor}{rgb}{0, 0, 0}
\definecolor{warningcolor}{rgb}{1, 0, 1}
\definecolor{errorcolor}{rgb}{1, 0, 0}
\newenvironment{knitrout}{}{} % an empty environment to be redefined in TeX

\usepackage{alltt}

% Set lecture number for later use


% Part common to all the lectures
\subtitle{MATH 8xyz -- Lecture 23}
\author{\texorpdfstring{Julien Arino\newline Department of Mathematics @ University of Manitoba \newline Maud Menten Institute @ PIMS\newline\url{julien.arino@umanitoba.ca}}{Julien Arino}}
\date{Winter 20XX}

% Title of the lecture
\title{Models using continuous-time Markov chains}



\input{slides-setup-whiteBG.tex}

\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% TITLE AND OUTLINE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\titlepagewithfigure{FIGS-slides-admin/Gemini_Generated_Image_uckjmbuckjmbuckj.jpeg}
\outlinepage{FIGS-slides-admin/Gemini_Generated_Image_sq8p8jsq8p8jsq8p.jpeg}


%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%
\section{Why incorporate stochasticity?}
% The section page
\newSectionSlide{FIGS-slides-admin/Gemini_Generated_Image_tve93ftve93ftve9.jpeg}

\begin{frame}{At the beginning of the COVID-19 crisis}
\bbullet 
I was working under contract with the Public Health Agency of Canada on \emph{COVID-19 importation risk assessment}
\vfill
\bbullet 
Produced daily report with list of countries most likely to next report cases of COVID-19
\vfill
\bbullet
Used ensemble runs of a fitted global deterministic metapopulation model
\end{frame}

\maxFrameImage{FIGS/covid-cluster}

\begin{frame}
\bbullet Very very long days (18-20 hours, 7 days a week)
\vfill
\bbullet including a lot of time waiting for the ``cluster'' to finish
\vfill
$\implies$ PHAC gave me money for a cluster (yay Threadrippers!!!)
\vfill
$\implies$ Also thought about whether my model was really adequate as our focus switched from thinking about movement on a planetary scale to movement within Canadian provinces
\end{frame}

\begin{frame}{What is wrong with deterministic models?}
\bbullet I pointed out yesterday that SARS-CoV-2 is one \emph{single} realisation of a stochastic process
\vfill
\bbullet Deterministic models ``operate on averages'' over a large ($\to\infty$) number of realisations
\vfill
\bbullet If we want to get a better sense of what could happen, not only on average, then we need to see what can indeed happen
\end{frame}

\begin{frame}{My new focus -- Introductions}
\bbullet I started thinking in particular about \defword{introductions} (or importations) of pathogens into new populations
\vfill
\bbullet Indeed, introductions are an obligatory step in spatial spread
\end{frame}

\begin{frame}{First piece of evidence}
In real life, introductions of pathogens does not always follow the patter
\begin{center}
\{$\R_0<1 \implies \to$ DFE | $\R_0>1 \implies $ epidemic or $\to$ EEP\} 
\end{center}
\end{frame}

\maxFrameImage{FIGS/Delory_etal-cover}
\maxFrameImage{FIGS/Delory_etal-table}

\begin{frame}{Second piece of evidence}
The start of an outbreak can be extremely slow, with very few cases for quite a while
\end{frame}

\maxFrameImage{FIGS/select_Wyoming-Campbell_bars_zoom}

\begin{frame}{Why this is relevant}
Far from the only reason, but as an example: Canada has remote/isolated communities that are vulnerable to introductions of pathogens
\end{frame}

\maxFrameImage{FIGS/cities_roads_CAN-MB_detail.png}
\maxFrameImage{FIGS/nutrition-north-canada-eligibility.png}
\maxFrameImage{FIGS/Screenshot from 2024-06-25 14-42-25.png}
\maxFrameImage{FIGS/Screenshot from 2024-06-25 16-56-16.png}

\begin{frame}{For First Nation and MÃ©tis Communities}
  \defword{Remote} describes a \textbf{geographical area} where a community is \textbf{located over 350 km} from the \textbf{nearest service centre} \textbf{having year-round access} by land and/or water routes normally used in all weather conditions
  \vfill	
  \defword{Isolated} means a \textbf{geographical area} that has \textbf{scheduled flights} and good telephone service, but is \textbf{without year-round access} by land and/or water normally used in all weather conditions
  \vfill
  \defword{Remote-Isolated} means a \textbf{geographic area} that has \textbf{neither scheduled flights nor year-round access} by land and/or water routes normally that can be used in all weather conditions, irrespective of the level of telephone and radio service available
\end{frame}

\begin{frame}{For Inuit communities}
  Inuit Communities to be referred to as \defword{Inuit Nunangat}, not remote and isolated communities to respect the unique language and culture of Inuit regions, as well as the common challenges in social determinants of health, access to care, and infrastructure found across all Inuit communities
\end{frame}

\begin{frame}\frametitle{MB remote communities}
  \begin{quote}
  \defword{Remote communities} are communities in Manitoba that \textbf{do not have permanent road access} (i.e., no all-weather road), are \textbf{more than a four-hour drive} from a major rural hospital (and a dialysis unit), \textbf{or have rail or fly-in access only}. This includes Norway House, Lynn Lake, Leaf Rapids, Gillam, and Cross Lake. If most communities in a health district are designated as "remote", the entire district is designated as "remote". In Manitoba, remote districts include:
  \begin{itemize}
  \item Northern Health Region: NO23, NO13, NO25, NO16, NO22, NO26, NO28, NO31, and
  \item Interlake-Eastern Health Region: IE61.
  \end{itemize}
  \end{quote}
  \vfill
  \small
  Chartier M, Dart A, Tangri N, Komenda P, Walld R, Bogdanovic B, Burchill C, Koseva I, McGowan K, Rajotte L. Care of Manitobans Living with Chronic Kidney Disease. Winnipeg, MB.
  Manitoba Centre for Health Policy, December 2015
\end{frame}

\maxFrameImage{FIGS/remote-health-regions.png}

\begin{frame}{Travel to/from remote or isolated communities}
  How do you think this compares to travel in non-remote/isolated communities ?
  \vfill
  Residence time (the lake ecology version): theoretic time an average water or comparable molecule spends in a lake, considering inflow into and outflow from the lake
  \vfill
  Think of residence times in these communities: what is the average time a person spends in a remote or isolated community before leaving it?
  \vfill
  The \defword{residence time in a location} is the total number of trips inbound into and outbound from location over a duration of time (1 month here) divided by the normal population in the location 
\end{frame}

\maxFrameImage{FIGS/residence-time-in-airports.png}

\begin{frame}{The paradox of travel to/from remote/isolated communities}
Travel volumes small but movement rates high
\vfill
ICs are highly connected to the urban centre(s) they are subordinated to
\vfill
Further reinforced in Winnipeg by urban indigenous population (102,075 or 12.45\% of metro population), meaning many family connections exist
\end{frame}

% \begin{frame}{Travel restrictions/interruptions}
% During COVID, travelling above 53 north in MB was forbidden for anyone not resident above 53 north	
% \vfill
% If you wanted to fly to Nunavut, you needed to spend two weeks in quarantine in a hotel in Edmonton, Ottawa or Winnipeg
% \vfill
% Canada implemented two weeks quarantine when IB from abroad (with exceptions)
% \vfill
% Canada interrupted travel from a variety of places
% \end{frame}
% 
% 
% \begin{frame}\frametitle{Questions}
% 	\begin{itemize}
% 		\item What is the probability that an introduction is successful? \newline (note: I am judging things from the perspective of the pathogen)
% 		\vfill
% 		\item How long is the stochastic phase following an introduction?
% 		\newline (what Amy called the ``stuttering period'')
% 		\vfill
% 		\item What do the different control measures do, how good are they?
% 	\end{itemize}
% \end{frame}



%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%
\section{Continuous time Markov chains}
% The section page
\newSectionSlide{FIGS-slides-admin/Gemini_Generated_Image_bla659bla659bla6.jpeg}

\subsection{Continuous time Markov chains}
\newSubSectionSlide{FIGS-slides-admin/Gemini_Generated_Image_9agynl9agynl9agy.jpeg}
\begin{frame}
    \frametitle{From discrete to continuous time}
    \begin{block}{Discrete-Time Markov Chains (DTMCs)}
        A system transitions between states at fixed, discrete time steps ($n=0, 1, 2, \dots$)
        \begin{itemize}
            \item The future depends only on the present state (Markov Property)
            \item Governed by a \textbf{transition probability matrix} $P$, where $P_{ij}$ is the probability of moving from state $i$ to $j$ in one step
        \end{itemize}
    \end{block}
    
    \begin{block}{Continuous-Time Markov Chains (CTMCs)}
        A system can transition between states at \textbf{any point in time}
        \begin{itemize}
            \item Time spent in a state is a \textbf{continuous random variable}
            \item The ``holding time'' in any state $i$ follows an \textbf{exponential distribution} parameterised by an \textit{exit rate} $q_i$
            \item This is a direct consequence of the Markov Property being applied to continuous time (exponential is only continuous distribution that is ``memoryless'')
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Transition rates}
    Dynamics of a CTMC defined by \textbf{transition rates}, not probabilities

    \begin{definition}[Transition Rates]
        For two states $i \neq j$, the rate $q_{ij} \ge 0$ is the instantaneous rate of transition from state $i$ to state $j$
        \begin{itemize}
            \item For a small time interval $\Delta t$, the probability of transitioning from $i$ to $j$ is approximately $q_{ij} \Delta t$
            \item Total \defword{exit rate} from state $i$ is $q_i = \sum_{j \neq i} q_{ij}$
            \item Time spent in state $i$ is an exponential random variable $T_i \sim \text{E}(q_i)$
        \end{itemize}
    \end{definition}
\end{frame}
    
\begin{frame}{The generator matrix}
    \begin{block}{Generator matrix (Q-Matrix)}
        Collect all transition rates into a single matrix $Q$
        \begin{itemize}
            \item Off-diagonal: $Q_{ij} = q_{ij}$ for $i \neq j$ (The rate of going from $i$ to $j$)
            \item Diagonal: $Q_{ii} = -q_i = -\sum_{j \neq i} q_{ij}$. (The negative of the total exit rate from $i$)
        \end{itemize}
        A key property is that all rows of $Q$ sum to zero: $\sum_{j} Q_{ij} = 0$.
    \end{block}
    
\end{frame}


\begin{frame}
    \frametitle{Kolmogorov equations}
    Let $P(t)$ be the matrix where $P_{ij}(t) = \mathbb{P}(X(t)=j | X(0)=i)$. How does $P(t)$ evolve over time?
    \vspace{1em}
    
    \begin{alertblock}{Kolmogorov forward equations}
        Describes rate of change of probability of ending up in a target state $j$
        $$ \frac{d}{dt}P(t) = P(t)Q $$
        In element form:
        $$ P'_{ij}(t) = \sum_{k} P_{ik}(t) Q_{kj} $$
    \end{alertblock}
\end{frame}

\begin{frame}{Solution to the KFE}
        The solution is the \textbf{matrix exponential}
        $$ P(t) = e^{tQ} = \sum_{k=0}^{\infty} \frac{(tQ)^k}{k!} $$
        \vfill
        The generator matrix $Q$ ``generates'' the process's evolution
\end{frame}


% \begin{frame}
%     \frametitle{The Stationary Distribution}
%     What happens to the process after a long time? Does it settle into an equilibrium?
%     
%     \begin{definition}[Stationary Distribution]
%         A probability distribution $\boldsymbol{\pi} = (\pi_1, \pi_2, \dots)$ is called a \textbf{stationary distribution} if, once the system is in this distribution, it stays in it.
%         $$ \boldsymbol{\pi} P(t) = \boldsymbol{\pi} \quad \text{for all } t \ge 0 $$
%         This implies that the distribution is no longer changing, i.e., $\frac{d}{dt}(\boldsymbol{\pi}P(t)) = \mathbf{0}$.
%     \end{definition}
%     
%     
%     \begin{block}{Finding the Stationary Distribution}
%         If a unique stationary distribution exists, it can be found by solving the system of linear equations:
%         $$ \boldsymbol{\pi} Q = \mathbf{0} $$
%         subject to the constraint that $\pi$ is a probability distribution:
%         $$ \sum_i \pi_i = 1 $$
%         The equation $\boldsymbol{\pi} Q = \mathbf{0}$ represents the "global balance" condition: for each state $j$, the total rate of probability flow into $j$ equals the total rate of probability flow out of $j$.
%     \end{block}
% \end{frame}



\subsection{ODE and CTMC}
% The section page
\newSubSectionSlide{FIGS-slides-admin/Gemini_Generated_Image_5yvymh5yvymh5yvy.jpeg}


\begin{frame}{Converting your compartmental ODE model to CTMC}
    Easy as $\pi$ :)
\vfill
\begin{itemize}
    \item Compartmental ODE model focuses on flows into and out of compartments
    \vfill
    \item ODE model has as many equations as there are compartments
    \vfill
    \item Compartmental CTMC model focuses on transitions
    \vfill
    \item CTMC model has as many transitions as there are arrows between (or into or out of) compartments
\end{itemize}
\end{frame}


\begin{frame}{ODE to CTMC : focus on different components}
    \begin{center}
        \begin{tikzpicture}[auto,
            scale=1.2, every node/.style={transform shape},
            cloud/.style={minimum width={width("N-1")+2pt},
            draw, ellipse,fill=red!20}]
            \node[cloud, fill=green!90, double=red] (S) at (0,0) {$S$};
            \node[cloud, draw=none, fill=white] (h4) at (2,0) {};
            \node[cloud, fill=red!90, double=red] (I) at (4,0) {$I$};
            \node[cloud, fill=green!90] (S2) at (6,0) {$S$};
            \node[cloud, fill=red!90] (I2) at (8,0) {$I$};
            %% Flows (ODE)
            \path [line, bend left, very thick, dashed] (S) to node [midway, above] (TextNode) {$-\beta SI$} (h4);
            \path [line, bend left, very thick] (h4) to node [midway, below] (TextNode) {$+\gamma I$} (S);
            \path [line, bend left, very thick] (h4) to node [midway, above] (TextNode) {$+\beta SI$} (I);
            \path [line, bend left, very thick, dashed] (I) to node [midway, below] (TextNode) {$-\gamma I$} (h4);
            %% Flows (CTMC)
            \path [line, bend left, very thick, red] (S2) to node [midway, above, black] (TextNode) {$\beta SI$} (I2);
            \path [line, bend left, very thick, red] (I2) to node [midway, below] (TextNode) {$\gamma I$} (S2);
            %%
            \draw[very thick, dotted] (5,-2) -- (5,2);
            %%
            \node[style=rectangle] at (2,2) {ODE};
            \node[style=rectangle] at (7,2) {CTMC};
            %%
            \node[style=rectangle] (fODE) at (2,-2) {focus};
            \path [line, dotted,red] (fODE) to  (S.south);
            \path [line, dotted,red] (fODE) to  (I.south);
            \node[style=rectangle] (fCTMC) at (6,-2) {focus};
            \path [line, dotted,red] (fCTMC) to (6.75,0.3);
            \path [line, dotted,red] (fCTMC) to  (6.75,-0.475);
        \end{tikzpicture}        
    \end{center}
\end{frame}


\begin{frame}{SIS without demography}
    \begin{center}
        \begin{tabular}{cp{3cm}cc}
          \toprule
            Transition & Effect & Weight & Probability \\
            \midrule
            $S\to S-1$, $I\to I+1$ & new infection & $\beta SI$ & $\dfrac{\beta SI}{\beta SI+\gamma I}$ \\
            $S\to S+1$, $I\to I-1$ & recovery of an infectious & $\gamma I$ & $\dfrac{\gamma I}{\beta SI+\gamma I}$ \\
            \bottomrule
        \end{tabular}
    \end{center}
    \vfill
    States are $S,I$
\end{frame}


\begin{frame}{SIS with demography}
    \begin{center}
        \begin{tabular}{p{3cm}p{3cm}cc}
        \toprule
            Transition & Effect & Weight & Probability \\
          \midrule
            $S\to S+1$ & birth of a susceptible & $b$ & $\frac{b}{b+d(S+I)+\beta SI+\gamma I}$ \\
            $S\to S-1$ & death of a susceptible & $dS$ & $\frac{dS}{b+d(S+I)+\beta SI+\gamma I}$ \\
            $S\to S-1$, $I\to I+1$ & new infection & $\beta SI$ & $\frac{\beta SI}{b+d(S+I)+\beta SI+\gamma I}$ \\
            $I\to I-1$ & death of an infectious & $dI$ & $\frac{dI}{b+d(S+I)+\beta SI+\gamma I}$ \\
            $S\to S+1$, $I\to I-1$ & recovery of an infectious & $\gamma I$ & $\frac{\gamma I}{b+d(S+I)+\beta SI+\gamma I}$ \\
            \bottomrule
        \end{tabular}
    \end{center}
\vfill
States are $S,I$
\end{frame}


\begin{frame}[fragile]{Kermack \& McKendrick model}
    \begin{center}
        \begin{tabular}{cp{3cm}cc}
        \toprule
            Transition & Effect & Weight & Probability \\
            \midrule
            $S\to S-1$, $I\to I+1$ & new infection & $\beta SI$ & $\dfrac{\beta SI}{\beta SI+\gamma I}$ \\
            $I\to I-1$, $R\to R+1$ & recovery of an infectious & $\gamma I$ & $\dfrac{\gamma I}{\beta SI+\gamma I}$ \\
            \bottomrule
        \end{tabular}
    \end{center}
    \vfill
    States are $S,I,R$
\end{frame}


\subsection{Simulating CTMC (in theory)}
% The section page
\newSubSectionSlide{FIGS-slides-admin/Gemini_Generated_Image_5yvymh5yvymh5yvy.jpeg}


\begin{frame}{Gillespie's algorithm}
    \begin{itemize}
        \item A.k.a. the stochastic simulation algorithm (SSA)
        \vfill
        \item Derived in 1976 by Daniel Gillespie
        \vfill
        \item Generates possible solutions for CTMC
        \vfill
        \item Extremely simple, so worth learning how to implement; there are however packages that you can use (see later)
    \end{itemize}
\end{frame}


\begin{frame}{Gillespie's algorithm}
Suppose system has state $\mathbf{x}(t)$ with initial condition $\mathbf{x}(t_0)=\mathbf{x}_0$ and \emph{propensity functions} $a_i$ of elementary reactions
\vfill
set $t\leftarrow t_0$ and $\mathbf{x}(t)\leftarrow \mathbf{x}_0$\\
while {$t\leq t_f$}\\
-\qquad $\xi_t\leftarrow \sum_j a_j(\mathbf{x}(t))$\\
-\qquad Draw $\tau_t$ from $T\thicksim \mathcal{E}(\xi_t)$\\
-\qquad Draw $\zeta_t$ from $\mathcal{U}([0,1])$\\
-\qquad Find $r$, smallest integer s.t. $\sum_{k=1}^j a_k(\mathbf{x}(t))> \zeta_t\sum_j a_j(\mathbf{x}(t))=\zeta_t\xi_t$\\
-\qquad Effect the next reaction (the one indexed $r$)\\
-\qquad $t\leftarrow t+\tau_t$\\    
\end{frame}


\begin{frame}{Drawing at random from an exponential distribution}
    If you do not have an exponential distribution random number generator.. We want $\tau_t$ from $T\thicksim\mathcal{E}(\xi_t)$, i.e., $T$ has probability density function
    $$
    f(x,\xi_t)=
    \xi_te^{-\xi_t x}\mathbf{1}_{x\geq 0}
    $$
    Use cumulative distribution function $F(x,\xi_t)=\int_{-\infty}^x f(s,\xi_t)\,ds$
    $$
    F(x,\xi_t)=
    (1-e^{-\xi_t x})\mathbf{1}_{x\geq 0}
    $$
    which has values in $[0,1]$. So draw $\zeta$ from $\mathcal{U}([0,1])$ and solve $F(x,\xi_t)=\zeta$ for $x$
    \begin{align*}
    F(x,\xi_t)=\zeta & \Leftrightarrow 1-e^{-\xi_tx}=\zeta \\
    &\Leftrightarrow e^{-\xi_tx} = 1-\zeta \\
    &\Leftrightarrow \xi_tx = -\ln(1-\zeta) \\
    &\Leftrightarrow \boxed{x = \frac{-\ln(1-\zeta)}{\xi_t}}
    \end{align*}
\end{frame}


\begin{frame}{Gillespie's algorithm (SIS model with only I eq.)}
set $t\leftarrow t_0$ and $I(t)\leftarrow I(t_0)$\\
while {$t\leq t_f$}\\
-\qquad $\xi_t\leftarrow \beta (P^\star-i)i+\gamma i$\\
-\qquad Draw $\tau_t$ from $T\thicksim \mathcal{E}(\xi_t)$\\
-\qquad $v\leftarrow\left[\beta (P^\star-i)i,\xi_t\right]/\xi_t$\\
-\qquad Draw $\zeta_t$ from $\mathcal{U}([0,1])$\\
-\qquad Find $pos$ such that $v_{pos-1}\leq\zeta_t\leq v_{pos}$\\
-\qquad switch {$pos$}\\
\qquad\qquad - 1: New infection, $I(t+\tau_t)=I(t)+1$ \\
\qquad\qquad - 2: End of infectious period, $I(t+\tau_t)=I(t)-1$ \\
- $t\leftarrow t+\tau_t$
\end{frame}


\begin{frame}{Sometimes Gillespie goes bad}
    \begin{itemize}
        \item Recall that the inter-event time is exponentially distributed
        \item Critical step of the Gillespie algorithm:
        \begin{itemize}
            \item $\xi_t\leftarrow$ weight of all possible events (\emph{propensity})
            \item Draw $\tau_t$ from $T\thicksim \mathcal{E}(\xi_t)$
        \end{itemize}
        \item So the inter-event time $\tau_t\to 0$ if $\xi_t$ becomes very large for some $t$
        \item This can cause the simulation to grind to a halt
    \end{itemize}
\end{frame}


\begin{frame}{Example: a birth and death process}
    \begin{itemize}
        \item Individuals born at \emph{per capita} rate $b$
        \item Individuals die at \emph{per capita} rate $d$
        \item Let's implement this using classic Gillespie
    \end{itemize}
    \vfill
(See \href{https://raw.githubusercontent.com/julien-arino/3MC-course-epidemiological-modelling/main/CODE/simulate_birth_death_CTMC.R}{\code{simulate\_birth\_death\_CTMC.R}} on course GitHub repo)
\end{frame}


\begin{frame}{Gillespie's algorithm (birth-death model)}
set $t\leftarrow t_0$ and $N(t)\leftarrow N(t_0)$\\
while {$t\leq t_f$}\\
-\qquad $\xi_t\leftarrow (b+d)N(t)$\\
-\qquad Draw $\tau_t$ from $T\thicksim \mathcal{E}(\xi_t)$\\
-\qquad $v\leftarrow\left[bN(t),\xi_t\right]/\xi_t$\\
-\qquad Draw $\zeta_t$ from $\mathcal{U}([0,1])$\\
-\qquad Find $pos$ such that $v_{pos-1}\leq\zeta_t\leq v_{pos}$\\
-\qquad switch {$pos$}\\
\qquad\qquad - 1: Birth, $N(t+\tau_t)=N(t)+1$ \\
\qquad\qquad - 2: Death, $N(t+\tau_t)=N(t)-1$ \\
- $t\leftarrow t+\tau_t$    
\end{frame}

\begin{frame}[fragile, allowframebreaks]

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hldef{birth_death_CTMC} \hlkwb{=} \hlkwa{function}\hldef{(}\hlkwc{b} \hldef{=} \hlnum{0.01}\hldef{,} \hlkwc{d} \hldef{=} \hlnum{0.01}\hldef{) \{}
  \hldef{t_0} \hlkwb{=} \hlnum{0}    \hlcom{# Initial time}
  \hldef{N_0} \hlkwb{=} \hlnum{100}  \hlcom{# Initial population}

  \hlcom{# Vectors to store time and state. Initialise with initial condition.}
  \hldef{t} \hlkwb{=} \hldef{t_0}
  \hldef{N} \hlkwb{=} \hldef{N_0}

  \hldef{t_f} \hlkwb{=} \hlnum{1000}  \hlcom{# Final time}

  \hlcom{# Track the current time and state (could just check last entry in t}
  \hlcom{# and N, but will take more operations)}
  \hldef{t_curr} \hlkwb{=} \hldef{t_0}
  \hldef{N_curr} \hlkwb{=} \hldef{N_0}
  \hlkwa{while} \hldef{(t_curr}\hlopt{<=}\hldef{t_f) \{}
    \hldef{xi_t} \hlkwb{=} \hldef{(b}\hlopt{+}\hldef{d)}\hlopt{*}\hldef{N_curr}
    \hlkwa{if} \hldef{(N_curr} \hlopt{==} \hlnum{0}\hldef{) \{}
      \hlkwa{break} \hlcom{# Avoid error with rexp when xi_t = 0}
    \hldef{\}}
    \hldef{tau_t} \hlkwb{=} \hlkwd{rexp}\hldef{(}\hlnum{1}\hldef{,} \hlkwc{rate} \hldef{= xi_t)}
    \hldef{t_curr} \hlkwb{=} \hldef{t_curr}\hlopt{+}\hldef{tau_t}
    \hldef{v} \hlkwb{=} \hlkwd{c}\hldef{(b}\hlopt{*}\hldef{N_curr, xi_t)}\hlopt{/}\hldef{xi_t}
    \hldef{zeta_t} \hlkwb{=} \hlkwd{runif}\hldef{(}\hlkwc{n} \hldef{=} \hlnum{1}\hldef{)}
    \hldef{pos} \hlkwb{=} \hlkwd{findInterval}\hldef{(zeta_t, v)}\hlopt{+}\hlnum{1}
    \hlkwd{switch}\hldef{(pos,}
           \hldef{\{ N_curr} \hlkwb{=} \hldef{N_curr}\hlopt{+}\hlnum{1}\hldef{\},}  \hlcom{# Birth}
           \hldef{\{ N_curr} \hlkwb{=} \hldef{N_curr}\hlopt{-}\hlnum{1}\hldef{\})} \hlcom{# Death}
    \hldef{N} \hlkwb{=} \hlkwd{c}\hldef{(N, N_curr)}
    \hldef{t} \hlkwb{=} \hlkwd{c}\hldef{(t, t_curr)}
  \hldef{\}}
  \hlkwd{plot}\hldef{(t, N,} \hlkwc{type} \hldef{=} \hlsng{"l"}\hldef{,}
       \hlkwc{xlab} \hldef{=} \hlsng{"Time"}\hldef{,} \hlkwc{ylab} \hldef{=} \hlsng{"Population size"}\hldef{,}
       \hlkwc{main} \hldef{=} \hlkwd{paste}\hldef{(}\hlsng{"Birth-death CTMC with b ="}\hldef{, b,} \hlsng{"and d ="}\hldef{, d))}
\hldef{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

\end{frame}



\maxFrameImage{FIGS/L23-CTMC_birth_death_b0_01_d0_01-1.pdf}



\maxFrameImage{FIGS/L23-CTMC_birth_death_b0_01_d0_02-1.pdf}

\begin{frame}[fragile]{$b=0.03$ \& $d=0.01$...}
We want to run the function with these parameter values but I know in advance this will not work well, so let's tweak the function a bit. We add a test:
\vfill
\begin{lstlisting}
if (t[length(t)]-t[(length(t)-1)] < 1e-8) {
      # If the time step is too small, stop the simulation
      message("Stopping simulation because time step is too small")
      break
    }
\end{lstlisting}
\vfill
\end{frame}





\maxFrameImage{FIGS/L23-CTMC_birth_death_b0_03_d0_01-1.pdf}




\begin{frame}[fragile]{Last one did not go well}
    \begin{itemize}
        \item Wanted 1000 time units (days?)
        \item Interrupted at 142.1207898 because of the test
        \newline (Slide with $b<d$: sim stopped because the population went extinct, I did not stop it!)
        \item At stop time
        \begin{itemize}
            \item $N =$ 2119
            \item $|N| =$ 4030 (and $|t|$ as well, of course!)
            \item time was moving slowly
        \end{itemize}
    \end{itemize}
    \vfill
    
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{tail}\hldef{(}\hlkwd{diff}\hldef{(results}\hlopt{$}\hldef{t))}
\end{alltt}
\begin{verbatim}
## [1] 3.069438e-02 3.020631e-02 1.609191e-03 1.100855e-02 4.502316e-03
## [6] 4.972219e-06
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{frame}


\maxFrameImage{FIGS/L23-plot_CTMC_birth_death_b0_03_d0_01_interevent-1.pdf}

\subsection{Simulating CTMC (in practice)}
% The section page
\newSubSectionSlide{FIGS-slides-admin/Gemini_Generated_Image_5yvymh5yvymh5yvy.jpeg}

\begin{frame}{Tau-leaping (and packages) to the rescue!}
    \begin{itemize}
        \item \emph{Approximation} method (compared to classic Gillespie, which is exact)
        \item Roughly: consider "groups" of events instead of individual events
        \item Good news: \code{GillespieSSA2} and \code{adaptivetau}, two standard packages for SSA in \code{R}, implement tau leaping
    \end{itemize}
\end{frame}

\begin{frame}[fragile, allowframebreaks]

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hldef{(GillespieSSA2)}
\hldef{Pop} \hlkwb{<-} \hlnum{1000}
\hldef{I_0} \hlkwb{<-} \hlnum{2}
\hldef{IC} \hlkwb{<-} \hlkwd{c}\hldef{(}\hlkwc{S} \hldef{= (Pop}\hlopt{-}\hldef{I_0),} \hlkwc{I} \hldef{= I_0)}
\hldef{gamma} \hlkwb{=} \hlnum{1}\hlopt{/}\hlnum{3}
\hlcom{# R0=beta/gamma*S0, so beta=R0*gamma/S0}
\hldef{beta} \hlkwb{=} \hlkwd{as.numeric}\hldef{(}\hlnum{1.5}\hlopt{*}\hldef{gamma}\hlopt{/}\hldef{IC[}\hlsng{"S"}\hldef{])}
\hldef{params} \hlkwb{<-} \hlkwd{c}\hldef{(}\hlkwc{gamma} \hldef{= gamma,} \hlkwc{beta} \hldef{= beta)}
\hldef{t_f} \hlkwb{=} \hlnum{100}
\hldef{reactions} \hlkwb{<-} \hlkwd{list}\hldef{(}
  \hlkwd{reaction}\hldef{(}\hlsng{"beta*S*I"}\hldef{,} \hlkwd{c}\hldef{(}\hlkwc{S}\hldef{=}\hlopt{-}\hlnum{1}\hldef{,}\hlkwc{I}\hldef{=}\hlopt{+}\hlnum{1}\hldef{),} \hlsng{"new_infection"}\hldef{),}
  \hlkwd{reaction}\hldef{(}\hlsng{"gamma*I"}\hldef{,} \hlkwd{c}\hldef{(}\hlkwc{S}\hldef{=}\hlopt{+}\hlnum{1}\hldef{,}\hlkwc{I}\hldef{=}\hlopt{-}\hlnum{1}\hldef{),} \hlsng{"recovery"}\hldef{)}
\hldef{)}
\hlkwd{set.seed}\hldef{(}\hlkwa{NULL}\hldef{)}


\hldef{sol} \hlkwb{<-} \hlkwd{ssa}\hldef{(}
  \hlkwc{initial_state} \hldef{= IC,}
  \hlkwc{reactions} \hldef{= reactions,}
  \hlkwc{params} \hldef{= params,}
  \hlkwc{method} \hldef{=} \hlkwd{ssa_exact}\hldef{(),}
  \hlkwc{final_time} \hldef{= t_f,}
\hldef{)}
\hlkwd{plot}\hldef{(sol}\hlopt{$}\hldef{time, sol}\hlopt{$}\hldef{state[,}\hlsng{"I"}\hldef{],} \hlkwc{type} \hldef{=} \hlsng{"l"}\hldef{,}
     \hlkwc{xlab} \hldef{=} \hlsng{"Time (days)"}\hldef{,} \hlkwc{ylab} \hldef{=} \hlsng{"Number infectious"}\hldef{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\end{frame}

\maxFrameImage{FIGS/L23-sim-gillespie2-first-1.pdf}



\subsection{Parallelising your code in \code{R}}
% The section page
\newSubSectionSlide{FIGS-slides-admin/Gemini_Generated_Image_4oxcef4oxcef4oxc.jpeg}


\begin{frame}{Parallelisation}
    To see multiple realisations: good idea to parallelise, then interpolate results. Write a function, e.g.,  \code{run\_one\_sim} that .. runs one simulation
    \vfill
    Use some parallelisation mechanisms to run \code{run\_one\_sim} in parallel. One easy way to do it is to use a parallel version of \code{lapply}, which applies a function to a list
    \vfill
    Here, I am showing parallelisation using a recent-ish package called \code{future} (and \code{future.apply}, which contains the relevant \code{lapply} equivalent)
    \vfill
    I am also illustrating another SSA library that I find less tricky on Windows because the reactions are not precompiled: \code{adaptivetau}
\end{frame}

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hldef{(adaptivetau)}
\hlkwd{library}\hldef{(future.apply)}
\hlcom{# It is useful to have the transitions, rates and }
\hlcom{# names defined in a function}
\hldef{CTMC_SIS} \hlkwb{<-} \hlkwa{function}\hldef{() \{}
  \hlcom{# Define transitions for adaptivetau}
  \hldef{transitions} \hlkwb{<-} \hlkwd{list}\hldef{(}
    \hlkwd{c}\hldef{(}\hlkwc{S} \hldef{=} \hlopt{-}\hlnum{1}\hldef{,} \hlkwc{I} \hldef{=} \hlopt{+}\hlnum{1}\hldef{),}  \hlcom{# new_infection}
    \hlkwd{c}\hldef{(}\hlkwc{S} \hldef{=} \hlopt{+}\hlnum{1}\hldef{,} \hlkwc{I} \hldef{=} \hlopt{-}\hlnum{1}\hldef{)}   \hlcom{# recovery}
  \hldef{)}
  \hlcom{# Define rate function}
  \hldef{rates} \hlkwb{<-} \hlkwa{function}\hldef{(}\hlkwc{x}\hldef{,} \hlkwc{params}\hldef{,} \hlkwc{t}\hldef{) \{}
    \hlkwd{c}\hldef{(}
      \hldef{params[[}\hlsng{"beta"}\hldef{]]} \hlopt{*} \hldef{x[}\hlsng{"S"}\hldef{]} \hlopt{*} \hldef{x[}\hlsng{"I"}\hldef{],}
      \hldef{params[[}\hlsng{"gamma"}\hldef{]]} \hlopt{*} \hldef{x[}\hlsng{"I"}\hldef{]}
    \hldef{)}
  \hldef{\}}
  \hldef{event_names} \hlkwb{=} \hlkwd{c}\hldef{(}\hlsng{"new_infection"}\hldef{,} \hlsng{"recovery"}\hldef{)}
  \hlkwd{return}\hldef{(}\hlkwd{list}\hldef{(}\hlkwc{transitions} \hldef{= transitions,}
              \hlkwc{rates} \hldef{= rates,}
              \hlkwc{event_names} \hldef{= event_names))}
\hldef{\}}

\hldef{run_one_sim} \hlkwb{=} \hlkwa{function}\hldef{(}\hlkwc{CTMC}\hldef{,} \hlkwc{params}\hldef{) \{}
    \hldef{IC} \hlkwb{<-} \hlkwd{c}\hldef{(}\hlkwc{S} \hldef{= (params}\hlopt{$}\hldef{Pop}\hlopt{-}\hldef{params}\hlopt{$}\hldef{I_0),}
            \hlkwc{I} \hldef{= params}\hlopt{$}\hldef{I_0)}
    \hlkwd{set.seed}\hldef{(}\hlkwa{NULL}\hldef{)}
    \hldef{sol} \hlkwb{<-} \hlkwd{ssa.exact}\hldef{(}
        \hlkwc{init.values} \hldef{= IC,}
        \hlkwc{transitions} \hldef{= CTMC}\hlopt{$}\hldef{transitions,}
        \hlkwc{rateFunc} \hldef{= CTMC}\hlopt{$}\hldef{rates,}
        \hlkwc{params} \hldef{= params,}
        \hlkwc{tf} \hldef{= params}\hlopt{$}\hldef{t_f}
    \hldef{)}
    \hlcom{# Interpolate result (just I will do)}
    \hldef{wanted_t} \hlkwb{=}
      \hlkwd{seq}\hldef{(}\hlkwc{from} \hldef{=} \hlnum{0}\hldef{,} \hlkwc{to} \hldef{= params}\hlopt{$}\hldef{t_f,} \hlkwc{by} \hldef{=} \hlnum{0.01}\hldef{)}
    \hldef{interp_I} \hlkwb{=} \hlkwd{approx}\hldef{(}\hlkwc{x} \hldef{= sol[,}\hlsng{"time"}\hldef{],}
                      \hlkwc{y} \hldef{= sol[,}\hlsng{"I"}\hldef{],}
                      \hlkwc{xout} \hldef{= wanted_t)}
    \hlkwd{names}\hldef{(interp_I)} \hlkwb{=} \hlkwd{c}\hldef{(}\hlsng{"time"}\hldef{,} \hlsng{"I"}\hldef{)}
    \hldef{sol}\hlopt{$}\hldef{interp_I} \hlkwb{=} \hldef{interp_I}
    \hlcom{# Return result}
    \hlkwd{return}\hldef{(sol)}
\hldef{\}}

\hlcom{# By default, use all available cores}
\hlkwd{plan}\hldef{(multisession)}
\hlcom{## To use fewer workers, leaving one empty for }
\hlcom{# instance}
\hlcom{# plan(multisession, availableCores()-1)}
\hlcom{## To run sequentially}
\hlcom{# plan(sequential)}

\hlcom{# Set up parameters not needing computation}
\hldef{params} \hlkwb{<-} \hlkwd{list}\hldef{(}\hlkwc{gamma} \hldef{=} \hlnum{1}\hlopt{/}\hlnum{3}\hldef{,}
               \hlkwc{Pop} \hldef{=} \hlnum{1000}\hldef{,}
               \hlkwc{I_0} \hldef{=} \hlnum{2}\hldef{,}
               \hlkwc{R0} \hldef{=} \hlnum{1.5}\hldef{,}
               \hlkwc{t_f} \hldef{=} \hlnum{100}\hldef{,} \hlkwc{nb_sims} \hldef{=} \hlnum{50}\hldef{)}
\hldef{IC} \hlkwb{<-} \hlkwd{c}\hldef{(}\hlkwc{S} \hldef{= (params}\hlopt{$}\hldef{Pop}\hlopt{-}\hldef{params}\hlopt{$}\hldef{I_0),}
        \hlkwc{I} \hldef{= params}\hlopt{$}\hldef{I_0)}
\hlcom{# R0=beta/gamma*S0, so beta=R0*gamma/S0}
\hldef{params} \hlkwb{=}
  \hlkwd{c}\hldef{(params,}
    \hlkwc{beta} \hldef{=} \hlkwd{as.numeric}\hldef{(params}\hlopt{$}\hldef{R0}\hlopt{*}\hldef{params}\hlopt{$}\hldef{gamma} \hlopt{/}
                        \hldef{IC[}\hlsng{"S"}\hldef{]))}
\hlcom{# Run the simulation}
\hldef{CTMC} \hlkwb{<-} \hlkwd{CTMC_SIS}\hldef{()}
\hldef{SIMS} \hlkwb{=} \hlkwd{future_lapply}\hldef{(}
  \hlkwc{X} \hldef{=} \hlnum{1}\hlopt{:}\hldef{params}\hlopt{$}\hldef{nb_sims,}
  \hlkwc{FUN} \hldef{=}  \hlkwa{function}\hldef{(}\hlkwc{x}\hldef{)} \hlkwd{run_one_sim}\hldef{(CTMC, params))}
\hlcom{#  Liberate the workers!}
\hlkwd{stopCluster}\hldef{(cl)}
\end{alltt}


{\ttfamily\noindent\bfseries\color{errorcolor}{\#\# Error in stopCluster(cl): could not find function "{}stopCluster"{}}}\begin{alltt}
\hlcom{# Find max y value for plot}
\hldef{y_max} \hlkwb{=} \hlkwd{max}\hldef{(}\hlkwd{unlist}\hldef{(}\hlkwd{lapply}\hldef{(SIMS,} \hlkwa{function}\hldef{(}\hlkwc{x}\hldef{)} \hlkwd{max}\hldef{(x}\hlopt{$}\hldef{interp_I}\hlopt{$}\hldef{I))),}
            \hlkwc{na.rm} \hldef{=} \hlnum{TRUE}\hldef{)}
\hlcom{# Now plot}
\hlkwd{plot}\hldef{(SIMS[[}\hlnum{1}\hldef{]]}\hlopt{$}\hldef{interp_I}\hlopt{$}\hldef{time,}
     \hldef{SIMS[[}\hlnum{1}\hldef{]]}\hlopt{$}\hldef{interp_I}\hlopt{$}\hldef{I,}
     \hlkwc{type} \hldef{=} \hlsng{"l"}\hldef{,} \hlkwc{lwd} \hldef{=} \hlnum{0.5}\hldef{,}
     \hlkwc{xlab} \hldef{=} \hlsng{"Time (days)"}\hldef{,}
     \hlkwc{ylab} \hldef{=} \hlsng{"Number infectious"}\hldef{,}
     \hlkwc{ylim} \hldef{=} \hlkwd{c}\hldef{(}\hlnum{0}\hldef{, y_max),}
     \hlkwc{main} \hldef{=} \hlkwd{paste}\hldef{(}\hlsng{"CTMC with R0 ="}\hldef{, params}\hlopt{$}\hldef{R0))}
\hlkwa{for} \hldef{(i} \hlkwa{in} \hlnum{2}\hlopt{:}\hlkwd{length}\hldef{(SIMS)) \{}
  \hlkwd{lines}\hldef{(SIMS[[i]]}\hlopt{$}\hldef{interp_I}\hlopt{$}\hldef{time,}
        \hldef{SIMS[[i]]}\hlopt{$}\hldef{interp_I}\hlopt{$}\hldef{I,}
        \hlkwc{type} \hldef{=} \hlsng{"l"}\hldef{,} \hlkwc{lwd} \hldef{=} \hlnum{0.5}\hldef{)}
\hldef{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{frame}[fragile, allowframebreaks]{Common part -- The function we run}

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hldef{run_one_sim} \hlkwb{=} \hlkwa{function}\hldef{(}\hlkwc{params}\hldef{) \{}
    \hldef{IC} \hlkwb{<-} \hlkwd{c}\hldef{(}\hlkwc{S} \hldef{= (params}\hlopt{$}\hldef{Pop}\hlopt{-}\hldef{params}\hlopt{$}\hldef{I_0),} \hlkwc{I} \hldef{= params}\hlopt{$}\hldef{I_0)}
    \hldef{params_local} \hlkwb{<-} \hlkwd{c}\hldef{(}\hlkwc{gamma} \hldef{= params}\hlopt{$}\hldef{gamma,} \hlkwc{beta} \hldef{= params}\hlopt{$}\hldef{beta)}
    \hldef{reactions} \hlkwb{<-} \hlkwd{list}\hldef{(}
        \hlcom{# propensity function effects name for reaction}
        \hlkwd{reaction}\hldef{(}\hlsng{"beta*S*I"}\hldef{,} \hlkwd{c}\hldef{(}\hlkwc{S}\hldef{=}\hlopt{-}\hlnum{1}\hldef{,}\hlkwc{I}\hldef{=}\hlopt{+}\hlnum{1}\hldef{),} \hlsng{"new_infection"}\hldef{),}
        \hlkwd{reaction}\hldef{(}\hlsng{"gamma*I"}\hldef{,} \hlkwd{c}\hldef{(}\hlkwc{S}\hldef{=}\hlopt{+}\hlnum{1}\hldef{,}\hlkwc{I}\hldef{=}\hlopt{-}\hlnum{1}\hldef{),} \hlsng{"recovery"}\hldef{)}
    \hldef{)}
    \hlkwd{set.seed}\hldef{(}\hlkwa{NULL}\hldef{)}
    \hldef{sol} \hlkwb{<-} \hlkwd{ssa}\hldef{(}
      \hlkwc{initial_state} \hldef{= IC,}
      \hlkwc{reactions} \hldef{= reactions,}
      \hlkwc{params} \hldef{= params_local,}
      \hlkwc{method} \hldef{=} \hlkwd{ssa_exact}\hldef{(),}
      \hlkwc{final_time} \hldef{= params}\hlopt{$}\hldef{t_f,}
      \hlkwc{log_firings} \hldef{=} \hlnum{TRUE}    \hlcom{# This way we keep track of events}
    \hldef{)}
    \hlcom{# Interpolate result (just I will do)}
    \hldef{wanted_t} \hlkwb{=} \hlkwd{seq}\hldef{(}\hlkwc{from} \hldef{=} \hlnum{0}\hldef{,} \hlkwc{to} \hldef{= params}\hlopt{$}\hldef{t_f,} \hlkwc{by} \hldef{=} \hlnum{0.01}\hldef{)}
    \hldef{sol}\hlopt{$}\hldef{interp_I} \hlkwb{=} \hlkwd{approx}\hldef{(}\hlkwc{x} \hldef{= sol}\hlopt{$}\hldef{time,} \hlkwc{y} \hldef{= sol}\hlopt{$}\hldef{state[,}\hlsng{"I"}\hldef{],}
                          \hlkwc{xout} \hldef{= wanted_t)}
    \hlkwd{names}\hldef{(sol}\hlopt{$}\hldef{interp_I)} \hlkwb{=} \hlkwd{c}\hldef{(}\hlsng{"time"}\hldef{,} \hlsng{"I"}\hldef{)}
    \hlcom{# Return result}
    \hlkwd{return}\hldef{(sol)}
\hldef{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

\end{frame}

\maxFrameImage{FIGS/L23-parallel-CTMC-plot-1.pdf}

\begin{frame}[fragile]{Benefit of parallelisation}
    Run the parallel code for 100 sims between `tictoc::tic()` and `tictoc::toc()`, giving `66.958 sec elapsed`, then the sequential version
\begin{lstlisting}
tictoc::tic()
SIMS = lapply(X = 1:params$number_sims,
                FUN =  function(x) run_one_sim(params))
tictoc::toc()
\end{lstlisting}
    which gives `318.141 sec elapsed` on a 6C/12T Intel(R) Core(TM) i9-8950HK CPU @ 2.90GHz (4.75$\times$ faster) or `12.067 sec elapsed` versus `258.985 sec elapsed` on a 32C/64T AMD Ryzen Threadripper 3970X 32-Core Processor (21.46$\times$ faster !)
\end{frame}


\subsection{Example -- Stochastic phase of an epidemic}
% The section page
\newSubSectionSlide{FIGS-slides-admin/Gemini_Generated_Image_5yvymh5yvymh5yvy.jpeg}

\maxFrameImage{FIGS/ArinoMilliken-BMB}
\nocite{ArinoMilliken2022b}

\maxFrameImage{FIGS/select_Wyoming-Campbell_bars_zoom}

\begin{frame}
\frametitle{Investigating outbreak types using a simple CTMC SIS}
\[
\mathbf{X}(t)=\left(S^A(t),I^A(t)\right)
\]
\vfill
CTMC $\mathbf{X}(t)$ characterized by transitions
\begin{center}
  \begin{tabular}{ccc}
    \toprule
    Description & Transition & Rate \\
    \midrule
    Infection & $\left(S^A,I^A\right)\to \left(S^A-1,I^A+1\right)$ & $\beta^AS^AI^A$ \\
    Recovery & $\left(S^A,I^A\right)\to \left(S^A+1,I^A-1\right)$ & $\gamma^AI^A$ \\
    \bottomrule
  \end{tabular}
\end{center}
\end{frame}

\begin{frame}{Investigating outbreak types using a simple CTMC SIS \emph{with a twist}}
Regular chain of this type has $I=0$ as sole absorbing state
\vfill
We add another absorbing state: if $I=\hat I$, then the chain has \emph{left} the stochastic phase and is in a quasi-deterministic phase with exponential growth
\vfill
Doing this, time to absorption measures become usable additionally to first passage time ones
\vfill
And the question becomes: how long does the chain ``linger on'' (``stutter'') before it is absorbed? We define the inter-absorption trajectory as the stochastic phase
\end{frame}

\maxFrameImage{FIGS/illustration_stochastic_phase.png}
\maxFrameImage{FIGS/duration_stochastic_phase_1patch_pop1M_I0eq1.png}

\begin{frame}{Problem of the value of the upper bound $\hat I$}
  \begin{itemize}
    \item Choose $\hat I$ too small and the stochastic phase will not last long
    \vfill
    \item Choose $\hat I$ too large and absorption will only be at the DFE
    \vfill
    \item So, how does one choose $\hat I$ ?
    \begin{itemize}
      \item A formula of Whittle (1955) \nocite{whittle1955}
      \item Multitype branching process (MTBP)
    \end{itemize}
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%
\subsection{Value of travel control measures}
% The section page
\newSubSectionSlide{FIGS-slides-admin/Gemini_Generated_Image_bla65bbla65bbla6.jpeg}

\begin{frame}{}
  \centering
  \def\hstep{*3}
  \begin{tikzpicture}[scale=0.75, rotate=270,
    every node/.style={transform shape},
    auto,
    box/.style={minimum width={width("N-1")+2pt},
      draw, rectangle}]
    % Exporter
    \node [box] at (0\hstep,3) (SE) {$S_E$};
    \node [box] at (1\hstep,3) (LE) {$L_E$};
    \node [box] at (2\hstep,4.5) (DE) {$D_E$};
    \node [box] at (2\hstep,1.5) (UE) {$U_E$};
    \node [box] at (3\hstep,3) (RE) {$R_E$};
    %% Introduction layer
    % \node [box] at (0\hstep,9) (SI) {$S_I$};
    \node [box, fill=blue!50] at (1\hstep,9) (LI) {$L_{I}$};
    \node [box, fill=red!50] at (2\hstep,7.5) (DI) {$D_{I}$};
    \node [box, fill=blue!50] at (2\hstep,10.5) (UI) {$U_{I}$};
    %\node [box, fill=red!50] at (3\hstep,7.5) (RID) {$R_{ID}$};
    %% Community
    \node [box] at (0\hstep,13.5) (SC) {$S_C$};
    \node [box] at (1\hstep,13.5) (LC) {$L_{C}$};
    \node [box] at (2\hstep,15) (DC) {$D_{C}$};
    \node [box] at (2\hstep,12) (UXC) {$U_{C}$};
    \node [box] at (3\hstep,13.5) (RC) {$R_{C}$};
    %\node [box] at (3\hstep,12) (RCU) {$R_{CU}$};
    % Text
    \node[rotate=90] at (-1,2.5) {\Large\textbf{Exporter}};
    \node[rotate=90] at (-1,11.25) {\Large\textbf{Importer}};
    % "meta-boxes" around sets of compartments
    \draw [black,rounded corners] (-0.65,1) -- (-0.65,5) -- (3\hstep+0.7,5) -- (3\hstep+0.7,1) -- cycle;
    \draw [black,rounded corners] (-0.65,6.9) -- (-0.65,16) -- (3\hstep+0.7,16) -- (3\hstep+0.7,6.9) -- cycle;
    \draw [black,rounded corners, dotted] (-0.55,11.25) -- (3\hstep+0.6,11.25) -- (3\hstep+0.6,7.05) -- (-0.55,7.05)  -- cycle node at (2.75, 11) {\textbf{Introduction layer}};
    \draw [black,rounded corners, dotted] (-0.55,11.25) -- (3\hstep+0.6,11.25) -- (3\hstep+0.6,15.9) -- (-0.55,15.9)  -- cycle node at (2.2, 11.5) {\textbf{Community}};
    %% Flows in exporter
    \path [line,thick] (SE) to node [above, sloped] (TextNode) {$\Phi_E S_E$} (LE);
    \path [line,thick] (LE) to node [midway,above,sloped] (TextNode) {$p_E\varepsilon_E L_E$} (DE);
    \path [line,thick] (LE) to node [midway,above,sloped] (TextNode) {$(1-p_E)\varepsilon_E L_E$} (UE);
    \path [line,thick] (UE) to node [midway,above,sloped] (TextNode) {$(1-\delta_E)\gamma_E U_E$} (RE);
    \path [line,thick] (DE) to node [midway,above,sloped] (TextNode) {$(1-\delta_E)\gamma_E D_E$}  (RE);
    %\path [line, very thick] (DE) to node [pos=0.15, right=0.25cm] (TextNode) {$(1-\delta_E)\gamma_E D_E$}  (RE);
    %% Flows from exporter to importer
    \path [line,sloped] (SE) to node [pos=0.275, above] (TextNode) {$m_{S} S_E$} (SC);
    \path [line,dashed] (LE) to node [midway, above, sloped, rotate=180] (TextNode) {$m_L L_E$} (LI);
    \path [line,dashed] (DE) to node [midway, above, sloped, rotate=180] (TextNode) {$m_D D_E$} (DI);
    \path [line,dashed, bend right=20] (UE) to node [midway, above, sloped, rotate=180] (TextNode) {$m_U U_E$} (UI);
    %\path [line, thin, bend right=20] (RE) to node [midway, below, sloped] (TextNode) {$m_{R} R_E$} (RCU);
    \draw[-{Stealth}] (RE) -- (3\hstep+1,3) -- (3\hstep+1,13.5)  node [pos=0.29, above, sloped] (TextNode) {$m_{R} R_E$} -- (RC);
    %% Flows (introduction layer)
    % \path [line, very thick] (SI) to node [above, sloped] (TextNode) {$\Phi_I S_I$} (LI);
    \path [line,thick] (LI) to node [midway,below,sloped] (TextNode) {$p_{I}\varepsilon_I L_{I}$} (DI);
    \path [line,thick] (LI) to node [midway,above,sloped] (TextNode) {$(1-p_{I})\varepsilon_I L_{I}$} (UI);
    \path [line,thick] (DI) -- (3\hstep,7.5) -- node [midway, above,sloped] (TextNode) {$(1-\delta_I)\gamma_I D_{I}$} (RC);
    \path [line,thick] (UI) to node [midway,below,sloped] (TextNode) {$(1-\delta_I)\gamma_I U_{I}$} (RC);
    %% Flows (community)
    \path [line,thick] (SC) to node [midway, above, sloped] (TextNode) {$\Phi_C S_C$} (LC);
    \path [line,thick] (LC) to node [midway, above, sloped] (TextNode) {$p_C\varepsilon_C L_C$} (DC);
    \path [line,thick] (LC) to node [midway,above,sloped] (TextNode) {$(1-p_C)\varepsilon_C L_{C}$} (UXC);
    \path [line,thick] (DC) to node [midway, above,sloped] (TextNode) {$(1-\delta_C)\gamma_C D_{C}$} (RC);
    \path [line,thick] (UXC) to node [midway, above,sloped] (TextNode) {$(1-\delta_C)\gamma_C U_{C}$} (RC);
  \end{tikzpicture}		
\end{frame}

\maxFrameImage{FIGS/sim_2023_07_11-11_06_41_ID_9_run86.png}
\maxFrameImage{FIGS/sim_2023_07_11-11_06_41_ID_9_run2.png}
\maxFrameImage{FIGS/sim_2023_07_11-11_06_41_ID_9_run3.png}
\maxFrameImage{FIGS/sim_2023_07_11-11_06_41_ID_25_run5.png}
\maxFrameImage{FIGS/exporter_importer_panel_zoom.png}

\begin{frame}{One last thought for the road}
  V. Chetail. \href{https://doi.org/10.3389/fpos.2020.606307}{Crisis without borders: What does international law say about border closure in the context of Covid-19?} Frontiers in Political Science, 2 (12) (2020) \nocite{chetail2020crisis}
  \vfill
  \begin{quote}
    [..] a powerful expression of state's sovereignty, immigration control provides a typical avenue for governments to reassure their citizens and bolster a national sense of belonging, while providing an ideal scapegoat for their own failure or negligence.
  \end{quote}
\end{frame}



%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%
\section{Branching process approximations of CTMC}
% The section page
\newSectionSlide{FIGS-slides-admin/Gemini_Generated_Image_5yvymh5yvymh5yvy.jpeg}

\begin{frame}
    \frametitle{What is a Branching Process?}
    \begin{block}{The Core Idea}
        A branching process is a mathematical model for a population where individuals produce a random number of offspring and then die.
    \end{block}
    
    \begin{itemize}
        \item Think of bacteria splitting, a virus spreading, or even the survival of family surnames.
        \item We start with an initial population, $Z_0$.
        \item Each individual in generation $n$ produces a number of offspring for generation $n+1$.
        \item This "number of offspring" is a random variable. All individuals produce offspring according to the same probability distribution, independently of each other.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{The Galton-Watson Process}
    
    Let $Z_n$ be the size of the population in generation $n$. We typically start with $Z_0 = 1$.
    
    The population evolves according to the rule:
    $$ Z_{n+1} = \sum_{i=1}^{Z_n} X_{n,i} $$
    
    \begin{itemize}
        \item The term $X_{n,i}$ represents the number of offspring produced by the $i$-th individual in generation $n$.
        \item The variables $\{X_{n,i}\}$ are assumed to be \textbf{independent and identically distributed (i.i.d.)} integer-valued random variables.
        \item We call their common distribution $\{p_k\}_{k=0}^\infty$ the \textbf{offspring distribution}, where $p_k = P(X = k)$.
    \end{itemize}
    
    \begin{alertblock}{The Fundamental Questions}
    \begin{enumerate}
        \item What is the long-term expected size of the population?
        \item What is the probability that the population eventually dies out?
    \end{enumerate}
    \end{alertblock}
\end{frame}

\begin{frame}
    \frametitle{Mean Offspring}

    The fate of the population hinges on a single parameter: the mean of the offspring distribution

    $$ \mu = E[X] = \sum_{k=0}^{\infty} k \cdot p_k $$

    \begin{block}{Expected Population Size}
        Using the law of total expectation, we find the expected size of the next generation:
        $$ E[Z_{n+1} | Z_n] = E\left[\sum_{i=1}^{Z_n} X_{n,i} \bigg| Z_n\right] = Z_n E[X] = Z_n \mu $$

        Taking the expectation again, we get a simple recurrence:
        $$ E[Z_{n+1}] = \mu E[Z_n] $$

        This implies:
        $$ E[Z_n] = Z_0 \mu^n $$
    \end{block}
\end{frame}

% --- SLIDE 5: The Three Regimes of Population Growth ---
\begin{frame}
    \frametitle{The Three Regimes of Population Growth}

    The behavior of $E[Z_n] = Z_0 \mu^n$ suggests three distinct cases:

    \begin{columns}[T]
        \begin{column}{0.33\textwidth}
            \begin{block}{Subcritical ($\mu < 1$)}
                $E[Z_n] \to 0$. The population is expected to shrink. It goes extinct with probability 1.
            \end{block}
        \end{column}
        \begin{column}{0.33\textwidth}
            \begin{block}{Critical ($\mu = 1$)}
                $E[Z_n] = Z_0$. The population is expected to remain stable. Surprisingly, it still goes extinct with probability 1.
            \end{block}
        \end{column}
        \begin{column}{0.33\textwidth}
            \begin{block}{Supercritical ($\mu > 1$)}
                $E[Z_n] \to \infty$. The population is expected to grow exponentially. It has a non-zero probability of surviving forever.
            \end{block}
        \end{column}
    \end{columns}
\end{frame}

% --- SLIDE 6: Calculating the Extinction Probability ---
\begin{frame}
    \frametitle{Tool: The Probability Generating Function}

    To find the extinction probability, we need a powerful tool: the \textbf{probability generating function (PGF)} of the offspring distribution $X$.

    $$ G(s) = E[s^X] = \sum_{k=0}^{\infty} p_k s^k \quad \text{for } |s| \le 1 $$

    \begin{block}{Key Properties}
    \begin{itemize}
        \item $G(1) = \sum p_k = 1$
        \item The mean can be found from the derivative: $G'(1) = \sum k p_k = \mu$.
        \item The PGF of $Z_n$ is the $n$-th iterate of $G(s)$ with itself. If $G_n(s)$ is the PGF of $Z_n$, then $G_{n+1}(s) = G(G_n(s))$.
    \end{itemize}
    \end{block}

\end{frame}

% --- SLIDE 7: The Extinction Probability Equation ---
\begin{frame}
    \frametitle{The Extinction Probability Equation}
    Let $\pi_0$ be the probability of eventual extinction, starting with $Z_0=1$.
    $$ \pi_0 = P(\text{population dies out}) = \lim_{n \to \infty} P(Z_n = 0) $$

    Since $P(Z_n=0) = G_n(0)$, and $G_{n+1}(0) = G(G_n(0))$, in the limit the extinction probability $\pi_0$ must satisfy the equation:

    \begin{center}
        \Huge
        $ \pi_0 = G(\pi_0) $
    \end{center}



    \begin{theorem}
    The extinction probability $\pi_0$ is the \textbf{smallest non-negative solution} to the equation $s = G(s)$.
    \end{theorem}

    \begin{itemize}
        \item If $\mu \le 1$, the only solution in $[0,1]$ is $s=1$. So $\pi_0=1$.
        \item If $\mu > 1$, there is a unique solution in $[0,1)$, which is the extinction probability $\pi_0 < 1$.
    \end{itemize}
\end{frame}

% --- SLIDE 8: From Discrete to Continuous Time ---
\begin{frame}
    \frametitle{From Discrete to Continuous Time}

    \begin{block}{Limitation of Galton-Watson}
        Generations don't happen in synchronized steps in the real world. Individuals give birth and die at random times.
    \end{block}

    This leads us to \textbf{Continuous-Time Markov Chains (CTMCs)}.

    \begin{itemize}
        \item The state of the system is the population size, $k \in \{0, 1, 2, \dots\}$.
        \item Instead of generations, we have transition rates:
            \begin{itemize}
                \item $\lambda_k$: rate of birth when population is size $k$ (moves to $k+1$).
                \item $\delta_k$: rate of death when population is size $k$ (moves to $k-1$).
            \end{itemize}
        \item Often, we assume these rates are linear: $\lambda_k = k\lambda$ and $\delta_k = k\delta$. This means individuals act independently.
    \end{itemize}
\end{frame}

% --- SLIDE 9: Branching Process Approximation of a CTMC ---
\begin{frame}
    \frametitle{Branching Process Approximation of a CTMC}

    \begin{alertblock}{The Key Insight}
    At the beginning of an outbreak (or for a very large population), the dynamics caused by a single individual are largely independent of others.
    \end{alertblock}

    This allows us to approximate the start of a CTMC population process with a branching process.

    \textbf{Example: A Simple Epidemic (SIR Model)}
    \begin{itemize}
        \item $S$: Susceptible, $I$: Infected, $R$: Recovered.
        \item An infected person meets others at a certain rate. If they meet a susceptible, a new infection may occur (an "offspring").
        \item The infected person recovers (or dies) at another rate, ending their infectious period.
        \item \textbf{Question:} How many new infections does a single infected person cause on average?
    \end{itemize}
\end{frame}

% --- SLIDE 10: Case Study: The Basic Reproduction Number $\mathcal{R}_0$ ---
\begin{frame}
    \frametitle{Case Study: The Basic Reproduction Number $\mathcal{R}_0$}

    Consider a single infected individual in a large population of susceptibles.
    \begin{itemize}
        \item Let $\beta$ be the infection rate (rate of producing "offspring").
        \item Let $\gamma$ be the recovery rate (rate of "dying").
    \end{itemize}

    The individual's infectious lifetime is an exponential random variable with mean $1/\gamma$.



    The average number of secondary infections they cause is:
    $$ \mathcal{R}_0 = (\text{rate of infection}) \times (\text{average infectious period}) = \beta \times \frac{1}{\gamma} = \frac{\beta}{\gamma} $$

    \begin{block}{The Connection}
    $\mathcal{R}_0$ is precisely the \textbf{mean offspring number} $\mu$ for the embedded branching process that approximates the start of the epidemic.
    \end{block}
\end{frame}

% --- SLIDE 11: Applying Branching Theory to Epidemics ---
\begin{frame}
    \frametitle{Applying Branching Theory to Epidemics}

    The fate of the epidemic's initial phase is determined by $\mathcal{R}_0$:

    \begin{itemize}
        \item If $\mathcal{R}_0 \le 1$ ($\mu \le 1$): The number of infected individuals is a subcritical or critical process. The epidemic will die out with probability 1.

        \item If $\mathcal{R}_0 > 1$ ($\mu > 1$): The process is supercritical. There is a positive probability that the epidemic takes off and causes a major outbreak.
    \end{itemize}



    We can even calculate the probability of a major outbreak! It is $1 - \pi_0$, where $\pi_0$ is the extinction probability.

    For this simple birth-death infection process, the PGF is $G(s) = \frac{\gamma}{\beta+\gamma} + \frac{\beta}{\beta+\gamma}s$. Solving $s=G(s)$ gives the extinction probability:

    $$ \pi_0 = \frac{\gamma}{\beta} = \frac{1}{\mathcal{R}_0} $$

    The probability of a major outbreak is $1 - 1/\mathcal{R}_0$.
\end{frame}

% --- SLIDE 12: Summary ---
\begin{frame}
    \frametitle{Summary}

    \begin{itemize}
        \item \textbf{Branching Processes} model populations with i.i.d. offspring generation.

        \item The fate of the population is determined by the \textbf{mean offspring number} $\mu$. Extinction is certain if $\mu \le 1$.

        \item The \textbf{extinction probability} $\pi_0$ can be calculated as the smallest non-negative fixed point of the probability generating function $G(s)$.

        \item The initial stages of many large-scale \textbf{Continuous-Time Markov Chains} can be approximated by a branching process.

        \item This allows us to apply the theory to real-world problems, like calculating an epidemic's \textbf{basic reproduction number $\mathcal{R}_0$} and its probability of causing a major outbreak.
    \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%
% Convert the file to R code. Only include if including R code in the document,
% otherwise it will generate a meaningless file with just R and knitr options.


%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[allowframebreaks]{Bibliography}
\bibliographystyle{apalike}
\bibliography{local-bibliography}
\end{frame}




\end{document}
